{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/polarbear/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/polarbear/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/polarbear/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/js/src/theme.js","path":"js/src/theme.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/polarbear/.eslintrc","hash":"38131da004ee91a91f25644508b377b261f59687","modified":1515328833101},{"_id":"themes/polarbear/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1515328833101},{"_id":"themes/polarbear/README.md","hash":"28051a9876e18c26675101c671828e24930acba9","modified":1515328833101},{"_id":"themes/polarbear/_config.yml","hash":"b438fad429210aacee0d7ff549aec09f4cbc92c6","modified":1515332000447},{"_id":"themes/polarbear/package.json","hash":"645cc09cf8cfa5298aa897c1b7ec7d9605deaa81","modified":1515328833101},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1515328513158},{"_id":"source/_posts/testtag.md","hash":"052562a5fb20481df3524917452df5903ae81a20","modified":1515330611318},{"_id":"source/about/index.md","hash":"ec79f0d2e2fa17adff66c3f09ab418142c5df5da","modified":1515331958803},{"_id":"themes/polarbear/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1515328833081},{"_id":"themes/polarbear/.git/config","hash":"02a6d07f4f29bc2c61a992f6a496eb7b88928a6f","modified":1515328833081},{"_id":"themes/polarbear/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1515328831069},{"_id":"themes/polarbear/.git/index","hash":"7bbd0e0c08968449f306977ce3f104c02da1b8e7","modified":1515331823806},{"_id":"themes/polarbear/.git/packed-refs","hash":"8c89be73077e047618c270087179cfb2697e2243","modified":1515328833081},{"_id":"themes/polarbear/languages/default.yml","hash":"5687525dd72a436ce0970f0b844dc7251069400a","modified":1515328833101},{"_id":"themes/polarbear/languages/en.yml","hash":"5687525dd72a436ce0970f0b844dc7251069400a","modified":1515328833101},{"_id":"themes/polarbear/languages/zh-cn.yml","hash":"be347d8f215c1d36a7a906143b1411e5aaf5d500","modified":1515328833101},{"_id":"themes/polarbear/layout/_layout.swig","hash":"60ad6ead7c72b9d94a4adf073884edc23f0751ea","modified":1515328833101},{"_id":"themes/polarbear/layout/archive.swig","hash":"600c71de731ac0ac8c281c3c9df1d7e9b62d2a9d","modified":1515328833101},{"_id":"themes/polarbear/layout/categories.swig","hash":"21987803e162bd9383502d9de07d5d531b78cb53","modified":1515328833101},{"_id":"themes/polarbear/layout/index.swig","hash":"5c1dce2ea06d8de6f05f92f95cb1449cefc846bc","modified":1515328833101},{"_id":"themes/polarbear/layout/page.swig","hash":"a168c6e1dcf21af6408a713f8512b77de0dc60f3","modified":1515328833101},{"_id":"themes/polarbear/layout/post.swig","hash":"f7a8b96953374694c50d131b1b760fd84b2d2d51","modified":1515328833101},{"_id":"themes/polarbear/source/favicon.ico","hash":"7d7c441f635c35b73f060f698773b14b7f306f4c","modified":1515328833101},{"_id":"themes/polarbear/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1515328831069},{"_id":"themes/polarbear/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1515328831069},{"_id":"themes/polarbear/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1515328831069},{"_id":"themes/polarbear/.git/logs/HEAD","hash":"bcde33c7c37034d1cd10d737996295b4da4aef72","modified":1515328833081},{"_id":"themes/polarbear/layout/_macro/archive.swig","hash":"0f298085c0a1c556b41a5785e9fb3f2cacf01e34","modified":1515328833101},{"_id":"themes/polarbear/layout/_macro/post.swig","hash":"649d15fe32fa975a8444de66d3651e03b55e3cce","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/comments.swig","hash":"9ba815734a4d807859f0aeafd5536b2d35d26074","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/footer.swig","hash":"4b88f30ad6218c87d27bc5c5b37bbbd97732cf59","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/head.swig","hash":"44c45d90d9a3db3401f6aa219cd26f38cdd0960b","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/header.swig","hash":"2e7d1faf49dadbf87b5925ff8da643cb470d6199","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/widget.swig","hash":"d8181794388ef3baa26c2d5cf8d71ae05472b32e","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/comments.swig","hash":"256713e117d67e2caad21db52bc0d51460e4ff7e","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/config.swig","hash":"4532063827e51b5c0dc3f58ca8c37896959887ac","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/libs.swig","hash":"615f82ddd2f89e87a604b51773fd719c78f90580","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/theme.swig","hash":"44582de16d91f5cde5fa28a21db408385a46ff8e","modified":1515328833101},{"_id":"themes/polarbear/source/css/_base.scss","hash":"27c36dfe4b2d159c64e666bfe8561fbdc591e6a5","modified":1515328833101},{"_id":"themes/polarbear/source/css/_layout.scss","hash":"adfe6b08a183326e2115974860d1862288d4789c","modified":1515328833101},{"_id":"themes/polarbear/source/css/_variables.scss","hash":"d3f72d21bdd3cae17118323ae7f20f04d484a0f5","modified":1515328833101},{"_id":"themes/polarbear/source/css/style.scss","hash":"2f1d29a63c3c8f8c615049b0233db528b6ab3230","modified":1515328833101},{"_id":"themes/polarbear/.git/objects/pack/pack-141b6141d145942339eed204739cc17ac4a9f135.idx","hash":"61d359639649cd254d6bc6c0a8b2e476f841d932","modified":1515328833069},{"_id":"themes/polarbear/.git/refs/heads/master","hash":"fec0245bc6a1d11c80d2f5fff6ff6bc56b53756b","modified":1515328833081},{"_id":"themes/polarbear/layout/_partial/_head/meta.swig","hash":"5eef6defbaf10f3f6d3b341d2d1af2e4d7aeb5a9","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/_widget/categories.swig","hash":"8bb8094fd3d96c0dd7e58fd658384a5df3a7e2ec","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/_widget/custom.swig","hash":"3fd8e37b94982927fdd0eaa1f658ada660f23b9c","modified":1515328833101},{"_id":"themes/polarbear/layout/_partial/_widget/tags.swig","hash":"a14e2bda31b15cac11c29d0abb623543a6c87edc","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/_analytics/google-analytics.swig","hash":"f44684799386fbd4af6e5994b0c14c85eeff060c","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/_comments/disqus.swig","hash":"f0e8b2ff1556622c0dee10a82e77646695b0f8dd","modified":1515328833101},{"_id":"themes/polarbear/layout/_script/_comments/duoshou.swig","hash":"582cf94bc12b56c6a16b5f3aa0067b51f74b0d40","modified":1515328833101},{"_id":"themes/polarbear/source/css/_common/_animation.scss","hash":"725af3ea621de186d6d61749836d5b491a96c1e4","modified":1515328833101},{"_id":"themes/polarbear/source/css/_common/_normalize.scss","hash":"259a1a0584f43efa6de2573a45fedfd59d4f39c0","modified":1515328833101},{"_id":"themes/polarbear/source/css/_common/_utils.scss","hash":"7719505ff3185a9f8fad05fe092fa91dd63d900c","modified":1515328833101},{"_id":"themes/polarbear/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_archive.scss","hash":"d4fa3756a4cab145f76fccc3c69d81b3412cec36","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_categories.scss","hash":"eb9fa27704fa280c6e8cc7b7f44b283cd2fe4ad3","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_footer.scss","hash":"5d708caa8a96f84642404fe8a0d7a755092710db","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_header.scss","hash":"b4e97e6704ab530ec3b789866d689b736e36de9e","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_iconfont.scss","hash":"ae9d1019bdbe6de4fe97aabbd42f489039e978a0","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_pagination.scss","hash":"7362208b41453429adae449acc916f8633077248","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_post.scss","hash":"71bfa582c26c491c8791dadbc3cb135284a123a2","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_tags.scss","hash":"1928c8483f51035edccd6899d7f4ee06673f2804","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_widget.scss","hash":"2fcea4e8e43b79c73bf4bd6dbf0c1a2368d4c6ef","modified":1515328833101},{"_id":"themes/polarbear/source/js/src/bootstrap.js","hash":"edb8690492039f4a4c9b83a3b9abda6d8a214984","modified":1515328833101},{"_id":"themes/polarbear/source/js/src/theme.js","hash":"6b76d3006694d56c843b8f968f224985a3fcce4e","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.css","hash":"79df8b1839cbcb82a0fd9738289eb43c1bc77026","modified":1515328833105},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.js","hash":"39357ff994e53ea15c582b6106094396835a8be0","modified":1515328833105},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1515328833105},{"_id":"themes/polarbear/.git/objects/pack/pack-141b6141d145942339eed204739cc17ac4a9f135.pack","hash":"9e6b9897279cc90457080a9f97e98b9725b86a55","modified":1515328833069},{"_id":"themes/polarbear/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1515328833105},{"_id":"themes/polarbear/.git/logs/refs/heads/master","hash":"bcde33c7c37034d1cd10d737996295b4da4aef72","modified":1515328833081},{"_id":"themes/polarbear/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1515328833081},{"_id":"themes/polarbear/source/css/_partial/_post/_code.scss","hash":"446dbbc70ba45e41079e2954549c248f5affc7c0","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_post/_content.scss","hash":"899c7c25bfa4fe00d85734af0d71bc4caf2a7337","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_post/_footer.scss","hash":"d4c0fc62e69412304691d58984fec0aa963e1117","modified":1515328833101},{"_id":"themes/polarbear/source/css/_partial/_post/_header.scss","hash":"ceca6f4b00154542c57bc6fe451e01892a9338d2","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1515328833101},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1515328833101},{"_id":"themes/polarbear/.git/logs/refs/remotes/origin/HEAD","hash":"bcde33c7c37034d1cd10d737996295b4da4aef72","modified":1515328833081},{"_id":"source/_posts/HDU 2181 哈密顿绕行世界问题.md","hash":"541de84ef39fb626b81a3f01f14cffb71cac08f7","modified":1515377509556},{"_id":"source/_posts/[转载]KMP算法详解：简洁易懂的KMP算法.md","hash":"debe81d3927a51f1091a9a6a1204ad987e34f879","modified":1515378560012}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2018-01-07T13:32:38.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-01-07 21:32:38\n---\n","updated":"2018-01-07T13:32:38.803Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjc4tj2c00004wg3i0ckyx3j7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-01-07T13:21:25.333Z","updated":"2018-01-07T12:35:13.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc4tj2b00000wg3inmmhejx5","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"HDU 2181 哈密顿绕行世界问题","date":"2015-07-13T12:41:41.000Z","_content":"\n看到挺多人在写博客的，我也想来学习学习，接触ACM也快1年了吧，不过到现在还是个渣渣，不过正在努力提高！\n\n写的第一篇博客，哈密顿绕行世界问题：深度搜索问题（深搜）。与一般的地图找点（找出口问题）相似，只是搜索过程中需要记录每次走过的点，便于输出。题目如下：高手别喷，如有雷同，请勿见怪。\n\n题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=2181<link>\n\n\n``` bash\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n  \nconst int MAXN=21;  \n  \nusing namespace std;  \n  \nint way[MAXN];          //保存每次走过的城市  \nint sumWays=0;          //记录总共有多少方案  \nint cas;  \nbool mp[MAXN][MAXN];    //保存原始输入数据  \nbool used[MAXN];        //判断该点（城市）是否被用过  \n  \nvoid inPut(){  \n    int a,b,c;  \n    for(int i=1;i<=20;i++){  \n        scanf(\"%d%d%d\",&a,&b,&c);  \n        mp[i][a]=true;  //表示与i城市连通的城市a,b,c。（数组特殊用法  \n        mp[i][b]=true;  \n        mp[i][c]=true;  \n    }  \n}  \n  \nvoid dfs(int nowStep,int count){  \n    way[count]=nowStep;             //当前计数走的城市编号，便于输出  \n    if(count==19){                  //搜索结束条件：当20个城市全部走完时  \n        if(mp[nowStep][cas]){       //若能够回到原点，则输出  \n            printf(\"%d:  \", ++ sumWays);  \n            for(int i = 0; i < 20; ++ i){  \n                printf(\"%d \", way[i]);  \n            }  \n            printf(\"%d\\n\", way[0]);  \n        }  \n    }  \n    else{  \n        for(int j = 1; j <= 20; j ++){  //找某条路是否连通，且通往该城市未被走过  \n            if(mp[nowStep][j] && !used[j]){  \n                used[j] = true;  \n                dfs(j, count+1);  \n                used[j] = false;    //记得消除！  \n            }  \n        }  \n    }  \n    return ;  \n}  \n  \nint main()  \n{  \n    memset(mp,false,sizeof(mp));  \n    inPut();  \n    while(scanf(\"%d\",&cas)&&cas){  \n        sumWays=0;  \n        memset(used,false,sizeof(used));  \n        //memset(way,0,sizeof(mp));  \n        used[cas]=true;  \n        dfs(cas,0); //深搜递归  \n    }  \n    return 0;  \n}  \n\n```","source":"_posts/HDU 2181 哈密顿绕行世界问题.md","raw":"---\ntitle: HDU 2181 哈密顿绕行世界问题\ndate: 2015-07-13 20:41:41\ntags: \"ACM&OJ\"\n---\n\n看到挺多人在写博客的，我也想来学习学习，接触ACM也快1年了吧，不过到现在还是个渣渣，不过正在努力提高！\n\n写的第一篇博客，哈密顿绕行世界问题：深度搜索问题（深搜）。与一般的地图找点（找出口问题）相似，只是搜索过程中需要记录每次走过的点，便于输出。题目如下：高手别喷，如有雷同，请勿见怪。\n\n题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=2181<link>\n\n\n``` bash\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n  \nconst int MAXN=21;  \n  \nusing namespace std;  \n  \nint way[MAXN];          //保存每次走过的城市  \nint sumWays=0;          //记录总共有多少方案  \nint cas;  \nbool mp[MAXN][MAXN];    //保存原始输入数据  \nbool used[MAXN];        //判断该点（城市）是否被用过  \n  \nvoid inPut(){  \n    int a,b,c;  \n    for(int i=1;i<=20;i++){  \n        scanf(\"%d%d%d\",&a,&b,&c);  \n        mp[i][a]=true;  //表示与i城市连通的城市a,b,c。（数组特殊用法  \n        mp[i][b]=true;  \n        mp[i][c]=true;  \n    }  \n}  \n  \nvoid dfs(int nowStep,int count){  \n    way[count]=nowStep;             //当前计数走的城市编号，便于输出  \n    if(count==19){                  //搜索结束条件：当20个城市全部走完时  \n        if(mp[nowStep][cas]){       //若能够回到原点，则输出  \n            printf(\"%d:  \", ++ sumWays);  \n            for(int i = 0; i < 20; ++ i){  \n                printf(\"%d \", way[i]);  \n            }  \n            printf(\"%d\\n\", way[0]);  \n        }  \n    }  \n    else{  \n        for(int j = 1; j <= 20; j ++){  //找某条路是否连通，且通往该城市未被走过  \n            if(mp[nowStep][j] && !used[j]){  \n                used[j] = true;  \n                dfs(j, count+1);  \n                used[j] = false;    //记得消除！  \n            }  \n        }  \n    }  \n    return ;  \n}  \n  \nint main()  \n{  \n    memset(mp,false,sizeof(mp));  \n    inPut();  \n    while(scanf(\"%d\",&cas)&&cas){  \n        sumWays=0;  \n        memset(used,false,sizeof(used));  \n        //memset(way,0,sizeof(mp));  \n        used[cas]=true;  \n        dfs(cas,0); //深搜递归  \n    }  \n    return 0;  \n}  \n\n```","slug":"HDU 2181 哈密顿绕行世界问题","published":1,"updated":"2018-01-08T02:11:49.556Z","_id":"cjc5kckyo0000ck3igpv6ge6m","comments":1,"layout":"post","photos":[],"link":"","content":"<p>看到挺多人在写博客的，我也想来学习学习，接触ACM也快1年了吧，不过到现在还是个渣渣，不过正在努力提高！</p>\n<p>写的第一篇博客，哈密顿绕行世界问题：深度搜索问题（深搜）。与一般的地图找点（找出口问题）相似，只是搜索过程中需要记录每次走过的点，便于输出。题目如下：高手别喷，如有雷同，请勿见怪。</p>\n<p>题目链接: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2181\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=2181</a><link></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;iostream&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;cstdio&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;cstring&gt;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">const int MAXN=21;  </span><br><span class=\"line\">  </span><br><span class=\"line\">using namespace std;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int way[MAXN];          //保存每次走过的城市  </span><br><span class=\"line\">int sumWays=0;          //记录总共有多少方案  </span><br><span class=\"line\">int cas;  </span><br><span class=\"line\">bool mp[MAXN][MAXN];    //保存原始输入数据  </span><br><span class=\"line\">bool used[MAXN];        //判断该点（城市）是否被用过  </span><br><span class=\"line\">  </span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">inPut</span></span>()&#123;  </span><br><span class=\"line\">    int a,b,c;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(int i=1;i&lt;=20;i++)&#123;  </span><br><span class=\"line\">        scanf(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);  </span><br><span class=\"line\">        mp[i][a]=<span class=\"literal\">true</span>;  //表示与i城市连通的城市a,b,c。（数组特殊用法  </span><br><span class=\"line\">        mp[i][b]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">        mp[i][c]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">void dfs(int nowStep,int count)&#123;  </span><br><span class=\"line\">    way[count]=nowStep;             //当前计数走的城市编号，便于输出  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==19)&#123;                  //搜索结束条件：当20个城市全部走完时  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nowStep][cas])&#123;       //若能够回到原点，则输出  </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d:  \"</span>, ++ sumWays);  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = 0; i &lt; 20; ++ i)&#123;  </span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, way[i]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, way[0]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int j = 1; j &lt;= 20; j ++)&#123;  //找某条路是否连通，且通往该城市未被走过  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nowStep][j] &amp;&amp; !used[j])&#123;  </span><br><span class=\"line\">                used[j] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">                dfs(j, count+1);  </span><br><span class=\"line\">                used[j] = <span class=\"literal\">false</span>;    //记得消除！  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">return</span> ;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int main()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    memset(mp,<span class=\"literal\">false</span>,sizeof(mp));  </span><br><span class=\"line\">    inPut();  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(scanf(<span class=\"string\">\"%d\"</span>,&amp;cas)&amp;&amp;cas)&#123;  </span><br><span class=\"line\">        sumWays=0;  </span><br><span class=\"line\">        memset(used,<span class=\"literal\">false</span>,sizeof(used));  </span><br><span class=\"line\">        //memset(way,0,sizeof(mp));  </span><br><span class=\"line\">        used[cas]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">        dfs(cas,0); //深搜递归  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>看到挺多人在写博客的，我也想来学习学习，接触ACM也快1年了吧，不过到现在还是个渣渣，不过正在努力提高！</p>\n<p>写的第一篇博客，哈密顿绕行世界问题：深度搜索问题（深搜）。与一般的地图找点（找出口问题）相似，只是搜索过程中需要记录每次走过的点，便于输出。题目如下：高手别喷，如有雷同，请勿见怪。</p>\n<p>题目链接: <a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2181\" target=\"_blank\" rel=\"noopener\">http://acm.hdu.edu.cn/showproblem.php?pid=2181</a><link></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#include &lt;iostream&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;cstdio&gt;  </span></span><br><span class=\"line\"><span class=\"comment\">#include &lt;cstring&gt;  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">const int MAXN=21;  </span><br><span class=\"line\">  </span><br><span class=\"line\">using namespace std;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int way[MAXN];          //保存每次走过的城市  </span><br><span class=\"line\">int sumWays=0;          //记录总共有多少方案  </span><br><span class=\"line\">int cas;  </span><br><span class=\"line\">bool mp[MAXN][MAXN];    //保存原始输入数据  </span><br><span class=\"line\">bool used[MAXN];        //判断该点（城市）是否被用过  </span><br><span class=\"line\">  </span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">inPut</span></span>()&#123;  </span><br><span class=\"line\">    int a,b,c;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(int i=1;i&lt;=20;i++)&#123;  </span><br><span class=\"line\">        scanf(<span class=\"string\">\"%d%d%d\"</span>,&amp;a,&amp;b,&amp;c);  </span><br><span class=\"line\">        mp[i][a]=<span class=\"literal\">true</span>;  //表示与i城市连通的城市a,b,c。（数组特殊用法  </span><br><span class=\"line\">        mp[i][b]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">        mp[i][c]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">void dfs(int nowStep,int count)&#123;  </span><br><span class=\"line\">    way[count]=nowStep;             //当前计数走的城市编号，便于输出  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==19)&#123;                  //搜索结束条件：当20个城市全部走完时  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nowStep][cas])&#123;       //若能够回到原点，则输出  </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d:  \"</span>, ++ sumWays);  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(int i = 0; i &lt; 20; ++ i)&#123;  </span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, way[i]);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, way[0]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(int j = 1; j &lt;= 20; j ++)&#123;  //找某条路是否连通，且通往该城市未被走过  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nowStep][j] &amp;&amp; !used[j])&#123;  </span><br><span class=\"line\">                used[j] = <span class=\"literal\">true</span>;  </span><br><span class=\"line\">                dfs(j, count+1);  </span><br><span class=\"line\">                used[j] = <span class=\"literal\">false</span>;    //记得消除！  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">return</span> ;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">int main()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    memset(mp,<span class=\"literal\">false</span>,sizeof(mp));  </span><br><span class=\"line\">    inPut();  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(scanf(<span class=\"string\">\"%d\"</span>,&amp;cas)&amp;&amp;cas)&#123;  </span><br><span class=\"line\">        sumWays=0;  </span><br><span class=\"line\">        memset(used,<span class=\"literal\">false</span>,sizeof(used));  </span><br><span class=\"line\">        //memset(way,0,sizeof(mp));  </span><br><span class=\"line\">        used[cas]=<span class=\"literal\">true</span>;  </span><br><span class=\"line\">        dfs(cas,0); //深搜递归  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"(转) KMP算法详解：简洁易懂的KMP算法","date":"2015-07-20T02:08:40.000Z","_content":"转自 http://www.matrix67.com/blog/archives/115\n\n（Matrix67原创）\n\n如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。\n\n我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=\"I'm matrix67\"，字符串B=\"matrix\"，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”\n    \n解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= \"aaaaaaaaaaaaaaaaaaaaaaaaaab\"，B=\"aaaaaaaab\"。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m<=n），即传说中的KMP算法。\n\n之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。\n\n个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。\n\n假如，A=\"abababaababacb\"，B=\"ababacb\"，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]<>B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B = a b a b a c b\n    j = 1 2 3 4 5 6 7\n```\n此时，A[6]<>B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j'。j'可能是多少呢？仔细想一下，我们发现，j'必须要使得B[1..j]中的头j'个字母和末j'个字母完全相等（这样j变成了j'后才能继续保持i和j的性质）。这个j'当然要越大越好。在这里，B [1..5]=\"ababa\"，头3个字母和末3个字母都是\"aba\"。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。\n再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]<>B[j+1]的情况：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n由于P[5]=3，因此新的j=3：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =         a b a b a c b\n    j =         1 2 3 4 5 6 7\n```\n这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =             a b a b a c b\n    j =             1 2 3 4 5 6 7\n```\n现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =               a b a b a c b\n    j =             0 1 2 3 4 5 6 7\n```\n终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=\"d\"时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。\n这个过程的代码很短（真的很短），我们在这里给出：\n```bash\nj:=0;\nfor i:=1 to n do\nbegin\n   while (j>0) and (B[j+1]<>A[i]) do j:=P[j];\n   if B[j+1]=A[i] then j:=j+1;\n   if j=m then\n   begin\n      writeln('Pattern occurs with shift ',i-m);\n      j:=P[j];\n   end;\nend;\n```\n最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。\n\n这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环\n。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。\n\n\n现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。\n\n为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。\n\n预处理不需要按照P的定义写成O(m<sup>2</sup>) 甚至 O(m<sup>3</sup>)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=\"ababacb\"，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]<>B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：\n```bash\n        1 2 3 4 5 6 7\n    B = a b a b a c b\n    P = 0 0 1 2 3 ?\n```\n\nP[5]=3是因为B[1..3]和B[3..5]都是\"aba\"；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是\"a\"。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]<>B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。\n\n怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：\n```bash\nP[1]:=0;\nj:=0;\nfor i:=2 to m do\nbegin\n   while (j>0) and (B[j+1]<>B[i]) do j:=P[j];\n   if B[j+1]=B[i] then j:=j+1;\n   P[i]:=j;\nend;\n```\n最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。\n\n串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。\n\n昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。\n还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。\n\nMatrix67原创\n转贴请注明出处","source":"_posts/[转载]KMP算法详解：简洁易懂的KMP算法.md","raw":"---\ntitle: (转) KMP算法详解：简洁易懂的KMP算法\ndate: 2015-07-20 10:08:40\ntags: \"ACM&OJ\"\n---\n转自 http://www.matrix67.com/blog/archives/115\n\n（Matrix67原创）\n\n如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。\n\n我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=\"I'm matrix67\"，字符串B=\"matrix\"，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”\n    \n解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= \"aaaaaaaaaaaaaaaaaaaaaaaaaab\"，B=\"aaaaaaaab\"。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m<=n），即传说中的KMP算法。\n\n之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。\n\n个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。\n\n假如，A=\"abababaababacb\"，B=\"ababacb\"，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]<>B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B = a b a b a c b\n    j = 1 2 3 4 5 6 7\n```\n此时，A[6]<>B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j'。j'可能是多少呢？仔细想一下，我们发现，j'必须要使得B[1..j]中的头j'个字母和末j'个字母完全相等（这样j变成了j'后才能继续保持i和j的性质）。这个j'当然要越大越好。在这里，B [1..5]=\"ababa\"，头3个字母和末3个字母都是\"aba\"。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。\n再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]<>B[j+1]的情况：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =     a b a b a c b\n    j =     1 2 3 4 5 6 7\n```\n由于P[5]=3，因此新的j=3：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =         a b a b a c b\n    j =         1 2 3 4 5 6 7\n```\n这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =             a b a b a c b\n    j =             1 2 3 4 5 6 7\n```\n现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：\n```bash\n    i = 1 2 3 4 5 6 7 8 9 ……\n    A = a b a b a b a a b a b …\n    B =               a b a b a c b\n    j =             0 1 2 3 4 5 6 7\n```\n终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=\"d\"时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。\n这个过程的代码很短（真的很短），我们在这里给出：\n```bash\nj:=0;\nfor i:=1 to n do\nbegin\n   while (j>0) and (B[j+1]<>A[i]) do j:=P[j];\n   if B[j+1]=A[i] then j:=j+1;\n   if j=m then\n   begin\n      writeln('Pattern occurs with shift ',i-m);\n      j:=P[j];\n   end;\nend;\n```\n最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。\n\n这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环\n。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。\n\n\n现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。\n\n为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。\n\n预处理不需要按照P的定义写成O(m<sup>2</sup>) 甚至 O(m<sup>3</sup>)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=\"ababacb\"，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]<>B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：\n```bash\n        1 2 3 4 5 6 7\n    B = a b a b a c b\n    P = 0 0 1 2 3 ?\n```\n\nP[5]=3是因为B[1..3]和B[3..5]都是\"aba\"；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是\"a\"。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]<>B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。\n\n怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：\n```bash\nP[1]:=0;\nj:=0;\nfor i:=2 to m do\nbegin\n   while (j>0) and (B[j+1]<>B[i]) do j:=P[j];\n   if B[j+1]=B[i] then j:=j+1;\n   P[i]:=j;\nend;\n```\n最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。\n\n串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。\n\n昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。\n还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。\n\nMatrix67原创\n转贴请注明出处","slug":"[转载]KMP算法详解：简洁易懂的KMP算法","published":1,"updated":"2018-01-08T02:29:20.012Z","_id":"cjc5kpi530002l03i3ol81yak","comments":1,"layout":"post","photos":[],"link":"","content":"<p>转自 <a href=\"http://www.matrix67.com/blog/archives/115\" target=\"_blank\" rel=\"noopener\">http://www.matrix67.com/blog/archives/115</a></p>\n<p>（Matrix67原创）</p>\n<p>如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。</p>\n<p>我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=”I’m matrix67”，字符串B=”matrix”，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”</p>\n<p>解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= “aaaaaaaaaaaaaaaaaaaaaaaaaab”，B=”aaaaaaaab”。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m&lt;=n），即传说中的KMP算法。</p>\n<p>之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。</p>\n<p>个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。</p>\n<p>假如，A=”abababaababacb”，B=”ababacb”，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]&lt;&gt;B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B = a b a b a c b</span><br><span class=\"line\">j = 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>此时，A[6]&lt;&gt;B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j’。j’可能是多少呢？仔细想一下，我们发现，j’必须要使得B[1..j]中的头j’个字母和末j’个字母完全相等（这样j变成了j’后才能继续保持i和j的性质）。这个j’当然要越大越好。在这里，B [1..5]=”ababa”，头3个字母和末3个字母都是”aba”。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =     a b a b a c b</span><br><span class=\"line\">j =     1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。<br>再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]&lt;&gt;B[j+1]的情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =     a b a b a c b</span><br><span class=\"line\">j =     1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>由于P[5]=3，因此新的j=3：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =         a b a b a c b</span><br><span class=\"line\">j =         1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =             a b a b a c b</span><br><span class=\"line\">j =             1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =               a b a b a c b</span><br><span class=\"line\">j =             0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=”d”时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。<br>这个过程的代码很短（真的很短），我们在这里给出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">j:=0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=1 to n <span class=\"keyword\">do</span></span><br><span class=\"line\">begin</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (j&gt;0) and (B[j+1]&lt;&gt;A[i]) <span class=\"keyword\">do</span> j:=P[j];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> B[j+1]=A[i] <span class=\"keyword\">then</span> j:=j+1;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> j=m <span class=\"keyword\">then</span></span><br><span class=\"line\">   begin</span><br><span class=\"line\">      writeln(<span class=\"string\">'Pattern occurs with shift '</span>,i-m);</span><br><span class=\"line\">      j:=P[j];</span><br><span class=\"line\">   end;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure></p>\n<p>最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。</p>\n<p>这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环<br>。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。</p>\n<p>现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。</p>\n<p>为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。</p>\n<p>预处理不需要按照P的定义写成O(m<sup>2</sup>) 甚至 O(m<sup>3</sup>)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=”ababacb”，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]&lt;&gt;B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    1 2 3 4 5 6 7</span><br><span class=\"line\">B = a b a b a c b</span><br><span class=\"line\">P = 0 0 1 2 3 ?</span><br></pre></td></tr></table></figure></p>\n<p>P[5]=3是因为B[1..3]和B[3..5]都是”aba”；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是”a”。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]&lt;&gt;B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。</p>\n<p>怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P[1]:=0;</span><br><span class=\"line\">j:=0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=2 to m <span class=\"keyword\">do</span></span><br><span class=\"line\">begin</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (j&gt;0) and (B[j+1]&lt;&gt;B[i]) <span class=\"keyword\">do</span> j:=P[j];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> B[j+1]=B[i] <span class=\"keyword\">then</span> j:=j+1;</span><br><span class=\"line\">   P[i]:=j;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure></p>\n<p>最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。</p>\n<p>串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。</p>\n<p>昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。<br>还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。</p>\n<p>Matrix67原创<br>转贴请注明出处</p>\n","site":{"data":{}},"excerpt":"","more":"<p>转自 <a href=\"http://www.matrix67.com/blog/archives/115\" target=\"_blank\" rel=\"noopener\">http://www.matrix67.com/blog/archives/115</a></p>\n<p>（Matrix67原创）</p>\n<p>如果机房马上要关门了，或者你急着要和MM约会，请直接跳到第六个自然段。</p>\n<p>我们这里说的KMP不是拿来放电影的（虽然我很喜欢这个软件），而是一种算法。KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=”I’m matrix67”，字符串B=”matrix”，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”</p>\n<p>解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= “aaaaaaaaaaaaaaaaaaaaaaaaaab”，B=”aaaaaaaab”。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m&lt;=n），即传说中的KMP算法。</p>\n<p>之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。</p>\n<p>个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。</p>\n<p>假如，A=”abababaababacb”，B=”ababacb”，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]&lt;&gt;B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B = a b a b a c b</span><br><span class=\"line\">j = 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>此时，A[6]&lt;&gt;B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j’。j’可能是多少呢？仔细想一下，我们发现，j’必须要使得B[1..j]中的头j’个字母和末j’个字母完全相等（这样j变成了j’后才能继续保持i和j的性质）。这个j’当然要越大越好。在这里，B [1..5]=”ababa”，头3个字母和末3个字母都是”aba”。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =     a b a b a c b</span><br><span class=\"line\">j =     1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。<br>再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]&lt;&gt;B[j+1]的情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =     a b a b a c b</span><br><span class=\"line\">j =     1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>由于P[5]=3，因此新的j=3：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =         a b a b a c b</span><br><span class=\"line\">j =         1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =             a b a b a c b</span><br><span class=\"line\">j =             1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = 1 2 3 4 5 6 7 8 9 ……</span><br><span class=\"line\">A = a b a b a b a a b a b …</span><br><span class=\"line\">B =               a b a b a c b</span><br><span class=\"line\">j =             0 1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure></p>\n<p>终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=”d”时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。<br>这个过程的代码很短（真的很短），我们在这里给出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">j:=0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=1 to n <span class=\"keyword\">do</span></span><br><span class=\"line\">begin</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (j&gt;0) and (B[j+1]&lt;&gt;A[i]) <span class=\"keyword\">do</span> j:=P[j];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> B[j+1]=A[i] <span class=\"keyword\">then</span> j:=j+1;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> j=m <span class=\"keyword\">then</span></span><br><span class=\"line\">   begin</span><br><span class=\"line\">      writeln(<span class=\"string\">'Pattern occurs with shift '</span>,i-m);</span><br><span class=\"line\">      j:=P[j];</span><br><span class=\"line\">   end;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure></p>\n<p>最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。</p>\n<p>这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环<br>。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。</p>\n<p>现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。</p>\n<p>为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。</p>\n<p>预处理不需要按照P的定义写成O(m<sup>2</sup>) 甚至 O(m<sup>3</sup>)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=”ababacb”，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]&lt;&gt;B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    1 2 3 4 5 6 7</span><br><span class=\"line\">B = a b a b a c b</span><br><span class=\"line\">P = 0 0 1 2 3 ?</span><br></pre></td></tr></table></figure></p>\n<p>P[5]=3是因为B[1..3]和B[3..5]都是”aba”；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是”a”。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]&lt;&gt;B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。</p>\n<p>怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P[1]:=0;</span><br><span class=\"line\">j:=0;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=2 to m <span class=\"keyword\">do</span></span><br><span class=\"line\">begin</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (j&gt;0) and (B[j+1]&lt;&gt;B[i]) <span class=\"keyword\">do</span> j:=P[j];</span><br><span class=\"line\">   <span class=\"keyword\">if</span> B[j+1]=B[i] <span class=\"keyword\">then</span> j:=j+1;</span><br><span class=\"line\">   P[i]:=j;</span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure></p>\n<p>最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。</p>\n<p>串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。</p>\n<p>昨天发现一个特别晕的事，知道怎么去掉BitComet的广告吗？把界面语言设成英文就行了。<br>还有，金山词霸和Dr.eye都可以去自杀了，Babylon素王道。</p>\n<p>Matrix67原创<br>转贴请注明出处</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjc5kckyo0000ck3igpv6ge6m","tag_id":"cjc5kckyv0001ck3iiicwe2uw","_id":"cjc5kckyy0002ck3iap2w0wpc"},{"post_id":"cjc5kpi530002l03i3ol81yak","tag_id":"cjc5kckyv0001ck3iiicwe2uw","_id":"cjc5kpi550003l03ia3yvz84t"}],"Tag":[{"name":"tag1","_id":"cjc4tj2b70002wg3i3mrt1p87"},{"name":"ACM&OJ","_id":"cjc5kckyv0001ck3iiicwe2uw"}]}}